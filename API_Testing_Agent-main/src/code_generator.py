"""
Python Test Code Generator Module

Generates executable Python Pytest code from test specifications.
"""

import logging
from pathlib import Path
from typing import Dict, Any, List
from jinja2 import Environment, FileSystemLoader, Template

from .test_generator import TestCase, TestGenerator

logger = logging.getLogger(__name__)


class CodeGenerator:
    """
    Generates Python Pytest code from test specifications.
    """
    
    def __init__(self, test_generator: TestGenerator, output_dir: Path, templates_dir: Path):
        """
        Initialize the code generator.
        
        Args:
            test_generator: Initialized TestGenerator instance
            output_dir: Output directory for generated code
            templates_dir: Directory containing Jinja2 templates
        """
        self.test_generator = test_generator
        self.output_dir = Path(output_dir)
        self.templates_dir = Path(templates_dir)
        
        # Setup Jinja2 environment
        self.env = self._setup_jinja_env()
    
    def _setup_jinja_env(self) -> Environment:
        """Setup Jinja2 environment for template rendering."""
        if self.templates_dir.exists():
            loader = FileSystemLoader(str(self.templates_dir))
        else:
            # Use default templates if directory doesn't exist
            loader = FileSystemLoader(str(Path(__file__).parent / "templates"))
        
        env = Environment(loader=loader, trim_blocks=True, lstrip_blocks=True)
        return env
    
    def generate_test_code(self) -> Dict[str, Path]:
        """
        Generate Python test code for all test cases.
        
        Returns:
            Dictionary mapping resource names to generated file paths
        """
        generated_files = {}
        
        # Group test cases by resource
        test_cases_by_resource = self._group_by_resource()
        
        for resource, test_cases in test_cases_by_resource.items():
            file_path = self._generate_test_module(resource, test_cases)
            generated_files[resource] = file_path
            logger.info(f"Generated test module: {file_path}")
        
        # Generate conftest.py
        conftest_path = self._generate_conftest()
        generated_files["conftest"] = conftest_path
        
        return generated_files
    
    def _group_by_resource(self) -> Dict[str, List[TestCase]]:
        """Group test cases by resource."""
        grouped = {}
        
        for test_case in self.test_generator.get_test_cases():
            # Extract resource from endpoint path
            path_parts = test_case.endpoint.strip('/').split('/')
            resource = path_parts[0] if path_parts else "unknown"
            
            if resource not in grouped:
                grouped[resource] = []
            grouped[resource].append(test_case)
        
        return grouped
    
    def _generate_test_module(self, resource: str, test_cases: List[TestCase]) -> Path:
        """Generate a test module for a resource."""
        # Create output directory
        self.output_dir.mkdir(parents=True, exist_ok=True)
        
        # Generate test code
        test_code = self._render_test_code(resource, test_cases)
        
        # Write to file
        file_path = self.output_dir / f"test_{resource}.py"
        file_path.write_text(test_code, encoding='utf-8')
        
        return file_path
    
    def _render_test_code(self, resource: str, test_cases: List[TestCase]) -> str:
        """Render test code using template."""
        # Prepare test data for template
        test_data = [
            {
                "id": tc.id,
                "name": tc.name,
                "endpoint": tc.endpoint,
                "method": tc.method,
                "description": tc.description,
                "scenario_type": tc.scenario_type,
                "expected_status": tc.expected_status,
                "assertions": tc.assertions,
                "tags": tc.tags,
            }
            for tc in test_cases
        ]
        
        # Try to use template if available
        try:
            template = self.env.get_template("test_module.jinja2")
            return template.render(
                resource=resource,
                test_cases=test_data,
                total_tests=len(test_cases),
            )
        except Exception as e:
            logger.warning(f"Failed to load template: {e}, generating default code")
            return self._generate_default_test_code(resource, test_cases)
    
    def _generate_default_test_code(self, resource: str, test_cases: List[TestCase]) -> str:
        """Generate default test code without template."""
        lines = [
            '"""',
            f'Test module for {resource} endpoints.',
            '',
            'Auto-generated by API Testing Agent',
            '"""',
            '',
            'import pytest',
            'import requests',
            'from typing import Dict, Any',
            '',
            '',
            '@pytest.fixture',
            'def api_client(config):',
            '    """API client fixture."""',
            '    return requests.Session()',
            '',
            '',
            '@pytest.fixture',
            'def auth_headers(config):',
            '    """Authentication headers fixture."""',
            '    return config.get_auth_headers()',
            '',
            '',
            f'class Test{resource.capitalize()}:',
            f'    """Test cases for {resource} endpoints."""',
            '',
        ]
        
        # Add test methods
        for test_case in test_cases:
            lines.extend(self._generate_test_method(test_case))
            lines.append('')
        
        return '\n'.join(lines)
    
    def _generate_test_method(self, test_case: TestCase) -> List[str]:
        """Generate a single test method."""
        lines = [
            f'    def {test_case.name}(self, api_client, auth_headers):',
            f'        """',
            f'        {test_case.description}',
            f'        ',
            f'        Endpoint: {test_case.method} {test_case.endpoint}',
            f'        Expected Status: {test_case.expected_status}',
            f'        """',
            f'        # Setup',
            f'        url = f"{{api_client.base_url}}{test_case.endpoint}"',
            f'        ',
            f'        # Execute',
            f'        response = api_client.request(',
            f'            method="{test_case.method}",',
            f'            url=url,',
            f'            headers=auth_headers,',
            f'        )',
            f'        ',
            f'        # Assert',
            f'        assert response.status_code == {test_case.expected_status}, \\',
            f'            f"Expected {test_case.expected_status}, got {{response.status_code}}"',
        ]
        
        for assertion in test_case.assertions:
            lines.append(f'        # {assertion}')
        
        return lines
    
    def _generate_conftest(self) -> Path:
        """Generate conftest.py with fixtures."""
        conftest_code = '''"""
Pytest configuration and fixtures for API Testing Agent.

Auto-generated by API Testing Agent
"""

import pytest
import requests
from pathlib import Path
from dotenv import load_dotenv
from src.config import Config


@pytest.fixture(scope="session")
def config():
    """Load configuration from environment."""
    # Load .env file
    env_file = Path(".env")
    if env_file.exists():
        load_dotenv(env_file)
    
    # Create and return config
    config = Config()
    config.validate()
    config.ensure_directories()
    return config


@pytest.fixture
def api_client(config):
    """Create API client with base URL and timeout."""
    session = requests.Session()
    session.base_url = config.api_base_url
    session.timeout = config.api_timeout
    
    # Add custom request method
    def request(method, url, **kwargs):
        if not url.startswith("http"):
            url = f"{session.base_url}{url}"
        return session.request(method, url, timeout=session.timeout, **kwargs)
    
    session.request = request
    return session


@pytest.fixture
def auth_headers(config):
    """Get authentication headers."""
    return config.get_auth_headers()


@pytest.fixture
def test_data():
    """Provide test data."""
    return {
        "valid_agent": {
            "name": "Test Agent",
            "email": "test@example.com",
            "commissionTier": 10,
        },
        "invalid_agent": {
            "name": "Test Agent",
            # Missing email
        },
    }
'''
        
        file_path = self.output_dir / "conftest.py"
        file_path.write_text(conftest_code, encoding='utf-8')
        
        return file_path
    
    def generate_test_specification(self, output_file: Path) -> Path:
        """Generate test specification document."""
        spec_lines = [
            "# Test Specification",
            "",
            "Auto-generated by API Testing Agent",
            "",
        ]
        
        # Group by endpoint
        endpoints = {}
        for test_case in self.test_generator.get_test_cases():
            key = f"{test_case.method} {test_case.endpoint}"
            if key not in endpoints:
                endpoints[key] = []
            endpoints[key].append(test_case)
        
        # Generate specification
        for endpoint, test_cases in endpoints.items():
            spec_lines.append(f"## {endpoint}")
            spec_lines.append("")
            
            for test_case in test_cases:
                spec_lines.append(f"### {test_case.name}")
                spec_lines.append(f"- **Type**: {test_case.scenario_type}")
                spec_lines.append(f"- **Description**: {test_case.description}")
                spec_lines.append(f"- **Expected Status**: {test_case.expected_status}")
                spec_lines.append(f"- **Assertions**:")
                for assertion in test_case.assertions:
                    spec_lines.append(f"  - {assertion}")
                spec_lines.append("")
        
        # Write specification
        output_file.parent.mkdir(parents=True, exist_ok=True)
        output_file.write_text('\n'.join(spec_lines), encoding='utf-8')
        
        return output_file
    
    def __repr__(self) -> str:
        """String representation of generator."""
        return f"CodeGenerator(output_dir={self.output_dir})"
